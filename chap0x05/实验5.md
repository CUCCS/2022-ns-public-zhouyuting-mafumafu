# 基于Scapy编写端口扫描器

## 实验目的

- 掌握网络扫描之端口状态探测的基本原理

## 实验环境

- Python 3.10.7
- Scapy 2.4.4
- nmap  

## 实验拓扑图

实验主机ip信息

- 网关
    - 172.16.111.1

- 攻击者主机
    - 172.16.111.113

- 受害者主机
    - 172.16.111.144

![](img/tuopu.jpg)

## 实验要求

- [x] 禁止探测互联网上的IP，严格遵守网络安全相关法律法规
- [x] 完成以下扫描技术的编程实现
  - [x] TCP connect scan / TCP stealth scan
  - [x] TCP Xmas scan /TCP fin scan / TCP null scan 
  - [x] UDP scan
- [x] 上述每种扫描技术的实现测试均需要测试端口状态为：`开放`、`关闭` 和 `过滤` 状态时的程序执行结果
- [x] 提供每一次扫描测试的抓包结果并分析与课本中的扫描方法原理是否相符？如果不同，试分析原因；
- [x] 在实验报告中详细说明实验网络环境拓扑、被测试 IP 的端口状态是如何模拟的
- [x] 复刻 `nmap` 的上述扫描技术实现的命令行参数开关

## 实验准备

- 被测试 IP 的端口状态模拟

    - 关闭状态：对应端口没有开启监听, 防火墙处于关闭状态。
    - 开启状态：对应端口开启监听，防火墙处于关闭状态。
    - 过滤状态：对应端口开启监听, 防火墙开启。

- 使用ufw相关命令

```javascript
#安装ufw
sudu apt update &&  apt install ufw
#允许端口访问
sudo ufw enable
#端口过滤状态
sudo ufw enable && ufw deny portno/tcp(udp)
#端口关闭状态
sudo ufw disable
```
- 开启和关闭端口相关命令

```bash
#开启
systemctl start apache2 # port 80
systemctl start dnsmasq # port 53
#关闭
systemctl stop apache2 # port 80
systemctl stop dnsmasq # port 53
```

- nmap

```bash
#下载安装
sudo apt update && sudo apt install nmap
#相关命令
sudo nmap -sT -p <port> <ip>
sudo nmap -sS -p <port> <ip>
sudo nmap -sX -p <port> <ip>
sudo nmap -sF -p <port> <ip>
sudo nmap -sN -p <port> <ip>
sudo nmap -sU -p <port> <ip>
```

- dnsmasq

```bash
#下载安装
sudo apt update && sudo apt install dnsmasq
```



## 实验过程

### TCP connect scan

- 端口状态
    - 开放：接收到的是一个 SYN/ACK 数据包
    - 关闭：接收到的是一个 RST/ACK 数据包
    - 过滤：目标主机没有任何响应

![](img/ppt1.png)

- 实验代码

```Python
#! /usr/bin/python

from scapy.all import *

dst_ip = "172.16.111.113"
dst_port=80
src_port = RandShort()

ret = sr1(IP(dst=dst_ip)/TCP(sport=src_port,dport=dst_port,flags="S"),timeout=10)

if ret is None:
    print("Filtered")

elif (ret.haslayer(TCP)):
    if (ret.getlayer(TCP).flags == 0x12):
    	send_rst = sr(IP(dst=dst_ip)/TCP(sport=src_port,dport=dst_port,flags="AR"),timeout=10)
        print ("Open")
    elif (ret.getlayer(TCP).flags == 0x14):
        print ("Closed")
```

#### 实验结果

**close**

![](img/tcp-cnt-close.png)

抓包结果

![](img/tcp-cnt-close-result.png)

- nmap

![](img/tcp-cnt-close-nmap.png)

抓包结果

![](img/tcp-cnt-close-nmaprst.png)

接受RST/ACK数据包，端口处于关闭状态。

**open**

![](img/tcp-cnt-open.png)

抓包结果

![](img/tcp-cnt-openrst.png)

- nmap

![](img/tcpcnt-open-nmap.png)

抓包结果

![](img/tcpcnt-open-nmaprst.png)

接受SYN/ACK包，处于开放状态。

**filter**

![](img/tcpcnt-filter.png)

抓包结果

![](img/tcpcnt-filterrst.png)

- nmap

![](img/tcpcnt-filter-nmap.png)

抓包结果

![](img/tcpcnt-filter-nmaprst.png)


接收不到响应包，处于过滤状态。


### TCP stealth scan

- 状态判断：
    - 先发送一个S，然后等待回应。如果有回应且标识为RA，说明目标端口处于关闭状态；如果有回应且标识为SA，说明目标端口处于开放状态。这时TCP stealth scan只回复一个R，不完成三次握手，直接取消建立连接;如果没有回应，则处于过滤状态。

- 实验代码：

```python
#! /usr/bin/python

from scapy.all import *

src_port = RandShort()
dst_ip = "172.16.111.113" 
dst_port = 80

resp = sr1(IP(dst=dst_ip)/TCP(sport=src_port,dport=dst_port,flags="S"),timeout=10)

if resp is None:
    print ("Filtered")

elif(resp.haslayer(TCP)):
    if(resp.getlayer(TCP).flags == 0x12):
        send_rst = sr(IP(dst=dst_ip)/TCP(sport=src_port,dport=dst_port,flags="R"),timeout=10)
        print ("Open")
    elif (resp.getlayer(TCP).flags == 0x14):
        print ("Closed")
    
```

#### 实验结果

**close**

关闭防火墙和端口

![](img/tcpstl-status.jpg)

执行代码结果

![](img/tcpstl-close.png)

抓包结果

![](img/tcpstl-closerst.png)

- nmap

![](img/tcpstl-close-nmap.png)

抓包结果

![](img/tcpstl-close-nmaprst.png)

接受RST/ACK数据包，端口处于关闭状态。

**open**

![](img/tcpstl-open.png)

抓包结果

![](img/tcpstl-openrst.png)

- nmap

![](img/tcpstl-open-nmap.png)

抓包结果

![](img/tcpstl-open-nmaprst.png)

接受SYN/ACK包，处于开放状态。

**filter**

![](img/tcpstl-filter.png)

抓包结果

![](img/tcpstl-filterrst.png)

- nmap

![](img/tcpstl-filter-nmap.png)

抓包结果

![](img/tcpstl-filter-nmaprst.png)

接收不到响应包，处于过滤状态。

### TCP Xmas scan

- 状态判断

Xmas 发送一个 TCP 包，并对 TCP 报文头 FIN、URG 和 PUSH 标记进行设置。若是关闭的端口则响应 RST 报文；开放或过滤状态下的端口则无任何响应。

- 实验代码

```python
from scapy.all import *

dst_ip = "172.16.111.113"
dst_port = 80

resp = sr1(IP(dst=dst_ip)/TCP(dport=dst_port,flags="FPU"),timeout=10)

if resp is None:
    print ("Open|Filtered")

elif(resp.haslayer(TCP)):
    if(resp.getlayer(TCP).flags == 0x14):
        print ("Closed")

#elif(resp.haslayer(ICMP)):
#    if(int(resp.getlayer(ICMP).type)==3 and int(resp.getlayer(ICMP).code) in [1,2,3,9,10,13]):
#        print ("Filtered")

```

#### 实验结果

**close**

![](img/tcpxmas-close.png)

抓包结果

![](img/tcpxmas-closerst.png)

- nmap

![](img/tcpxmas-close-nmap.png)

抓包结果

![](img/tcpxmas-close-nmaprst.png)

接受RST/ACK数据包，端口处于关闭状态。

**open**

![](img/tcpxmas-open.png)

抓包结果

![](img/tcpxmas-openrst.png)

- nmap

![](img/tcpxmas-open-nmap.png)

抓包结果

![](img/tcpxmas-open-nmaprst.png)

只收到了一个TCP包且没有响应，靶机端口处于过滤或开启状态。

**filter**

![](img/tcpxmas-filter.png)

抓包结果

![](img/tcpxmas-filterrst.png)

- nmap

![](img/tcpxmas-filter-nmap.png)

抓包结果

![](img/tcpxmas-filter-nmaprst.png)

只收到了一个TCP包且没有响应，靶机端口处于过滤或开启状态。

### TCP FIN scan

- 状态分析

仅发送 FIN 包，它可以直接通过防火墙，如果端口是关闭的就会回复一个 RST 包，如果端口是开放或过滤状态则对 FIN 包没有任何响应。

- 实验代码

```python
from scapy.all import *

dst_ip = "172.16.111.113" 
dst_port = 80

resp = sr1(IP(dst=dst_ip)/TCP(dport=dst_port,flags="F"),timeout=10)

if resp is None:
    print ("Open|Filtered")

elif(resp.haslayer(TCP)):
    if(resp.getlayer(TCP).flags == 0x14):
        print ("Closed")

```


#### 实验结果

**close**

![](img/tcpfin-close.png)

抓包结果

![](img/tcpfin-closerst.png)

- nmap

![](img/tcpfin-close-nmap.png)

抓包结果

![](img/tcpfin-close-nmaprst.png)

只收到了RST/ACK数据包，说明靶机端口处于关闭状态。

**open**

![](img/tcpfin-open.png)

抓包结果

![](img/tcpfin-openrst.png)

- nmap

![](img/tcpfin-open-nmap.png)

抓包结果

![](img/tcpfin-open-nmaprst.png)

只收到了一个TCP包且没有响应，靶机端口处于过滤或开启状态。

**filter**

![](img/tcpfin-filter.png)

抓包结果

![](img/tcpcnt-filterrst.png)

- nmap

![](img/tcpfin-filter-nmap.png)

抓包结果

![](img/tcpfin-filter-nmaprst.png)

只收到了一个TCP包且没有响应，靶机端口处于过滤或开启状态。

### TCP NULL scan

- 状态分析

发送一个 TCP 数据包，关闭所有 TCP 报文头标记。只有关闭的端口会发送 RST 响应。其优点和 Xmas 一样是隐蔽性好，缺点也是需要自己构造数据包，要求拥有超级用户或者授权用户权限。

- 实验代码

```python
from scapy.all import *

dst_ip = "172.16.111.113" 
dst_port = 80

resp = sr1(IP(dst=dst_ip)/TCP(dport=dst_port,flags=""),timeout=10)
# 攻击者发送TCP数据包时不设置任何位
if resp is None:
    print ("Open|Filtered")

if(resp.haslayer(TCP)):
    if(resp.getlayer(TCP).flags == 0x14):
        print ("Closed")

```

#### 实验结果

**close**

![](img/tcpnull-close.png)

抓包结果

![](img/tcpnull-closerst.png)

- nmap

![](img/tcpnull-close-nmap.png)

抓包结果

![](img/tcpnull-close-nmaprst.png)

只收到了RST/ACK数据包，说明靶机端口处于关闭状态。

**open**

![](img/tcpnull-open.png)

抓包结果

![](img/tcpnull-openrst.png)

- nmap

![](img/tcpnull-open-nmap.png)

抓包结果

![](img/tcpnull-open-nmap.png)

只收到了一个TCP包且没有响应，靶机端口处于过滤或开启状态。

**filter**

![](img/tcpnull-filter.png)

抓包结果

![](img/tcpnull-filterrst.png)

- nmap

![](img/tcpnull-filter-nmap.png)

抓包结果

![](img/tcpnull-filter-nmaprst.png)

只收到了一个TCP包且没有响应，靶机端口处于过滤或开启状态。

### UDP scan

- 状态分析


![](img/udp.png)

- 实验代码

```python
#! /usr/bin/python

from scapy.all import *

dst_ip="172.16.111.113"
dst_port=53

pkt = IP(dst=dst_ip)/UDP(dport=dst_port)
resp = sr1(pkt,timeout=10)

if resp is None:
	print("Open|Filtered")

elif resp.haslayer(UDP):#收到udp响应包
	print("Open")

elif resp.haslayer(ICMP):
	if int(resp.getlayer(ICMP).type)==3 and int(resp.getlayer(ICMP).code)==3:
		print("Close")#端口不可达错误
	elif int(resp.getlayer(ICMP).type)==3 and int(resp.getlayer(ICMP).code) in [1,2,9,10,13]:
		print("Filtered")#icmp其他错误，显示过滤状态

```


#### 实验结果

**close**

![](img/udp-close.png)

抓包结果

![](img/udp-closerst.png)

- nmap

![](img/udp-close-nmap.png)

抓包结果

![](img/udp-close-nmaprst.png)

靶机收到了来自攻击者的UDP数据包，并且发送了ICMP端口不可达的数据包，端口关闭。

**open**

![](img/udp-open.png)

抓包结果

![](img/udp-openrst.png)

- nmap

![](img/udp-open-nmap.png)

抓包结果

![](img/udp-open-nmaprst.png)

无回应，端口处于开放状态。

**filter**

![](img/udp-filter.png)

抓包结果

![](img/udp-filterrst.png)

- nmap

![](img/udp-filter-nmap.png)

抓包结果

![](img/udp-filter-nmaprst.png)

无回应。

## 实验结论

**课本中的扫描方法原理是否相符？不相符请说明原因**

相符


## 实验中遇到的问题和思考
1.在TCP-connect扫描的实验过程中，过滤状态下利用nmap方式实现，发现会发送两个tcp数据包，有点疑惑，但是主机端口其实依然处于过滤状态，因为主机没有收到任何回复包。

2.在TCP-stealth扫描的实验过程中，过滤状态下执行python代码报错，图片和原因如下：

![](img/problem1.png)

程序会首先执行(resp.haslayer(TCP))这一步下的代码，而不检查是否resp is None。

![](img/problem2.png)

调换两语句位置，先执行resp is None相关语句即可。


## 参考资料
[kali端口开放关闭命令](https://blog.csdn.net/weixin_35950531/article/details/116650944)

[Python+Scapy实现TCP扫描技术](https://blog.csdn.net/jackcily/article/details/83117884)

[2021-ns-public-Lychee00](https://github.com/CUCCS/2021-ns-public-Lychee00/blob/chap0x05/chap0x05/report05.md)

[nmap命令](https://blog.csdn.net/YUKIDDDD/article/details/119297244)

[第五章在线课件](http://courses.cuc.edu.cn/course/90732/learning-activity/full-screen#/378666)